---
layout: post
title: "[C++ Design Pattern] SOLID 디자인 원칙"
date: "2019-12-21"
# slug: "example_content"
description: "C++ Design Pattern 정리"
category: 
  - Design Pattern
# tags will also be used as html meta keywords.
tags:
  - Design Pattern
  - C++
comments: true
use_math: true
# ![](/images/posts/cpp_hot/img1.png){:.aligncenter}
# hyperlink : [name](url)
---
# Solid 디자인 원칙

## 1. 단일 책임 원칙, Single Responsibility Principle(SRP)

- 하나의 class는 하나의 책임(역할)만을 부여받는다.

- 하나의 class는 수정할 이유가 하나만 있어야 한다.
- ex) 메모장
  - 메모장은 글을 읽고 쓰는 책임만을 부여받는다.
  - 메모장의 데이터를 컴퓨터에 저장하는 기능은 메모장의 역할이 아니기 떄문에 새로운 클래스를 생성해서 그 역할을 대신 해야한다.
    - 그렇지 않으면 데이터 저장 방식이 바뀔 때, 메모장 클래스, 일기 클래스 등등 모든 클래스들의 저장 방식을 하나 하나 수정해야한다.

## 2. 열림-닫힘 원칙, Open-Closed Principle(OCP)

- 클래스, 함수 등 하나의 기능을 갖는 유닛은 확장에는 열려있어야 하고 수정에는 닫혀 있어야 한다.
  - 사용자가 기존의 기능을 똑같이 사용할 수 있어야함과 동시에 새로운 기능이 추가되어야 한다.



## 3. 리스코프 치환 원칙, Liskov Substitution Principle(LSP)

- 어떤 자식 객체에 접근할 떄 부모 객체의 인터페이스로 접근해도 문제가 없어야 한다.
  - 자식 클래스로 선언된 객체가 부모 클래스 형태의 인자를 전달 받더라도 자식 클래스에게 기대되는 역할을 수행해야한다.



## 4. 인터페이스 분리 원칙, Interface Segregation Principle(ISP)

- 필요에 따라 구현할 대상을 선별할 수 있도록 인터페이스를 별개로 두어야 한다.
- 기능별로 분리해서 interface를 구현해야 한다.
  - 필요한 기능만 사용하고 싶은데 하나의 interface로 묶여서 쓸데 없는 기능이 포함될 수도 있으므로.
  - 복합적인 기능이 필요시, 기능별로 분리된 interface를 묶어서 새로운 interface를 구성하면 된다.
- ex) 복합기
  - 한 machine interface로 print, scanner, fax를 모두 구현하지 말자.
  - printer interface, scanner interface, fax interface를 개별 구현
  - 복합기 interface는 위 세 가지 interface를 상속해서 구현
  - 이렇게 하면, printer만 구현할 수도 있고 fax 기능이 없는 복합기도 구현할 수 있다.



## 5. 의존성 역전 원칙, Dependency Inversion Principle(DIP)

1. 상위 모듈이 하위 모듈에 종속성을 가져서는 안된다. 양쪽 모두 추상화에 의존해야 한다.
   - 상위 모듈 - 하위 모듈 : 로그 리포팅 모듈 - 로그 획득 모듈
   - 로그 리포팅 모듈이 로그 획득 모듈의 구현체에 접근하면 안되고 획득 모듈의 interface에 접근해야 한다.
   - 추상화에 의존하지 않고 구현체에 의존하면,
     - 로그 획득 방식이 A에서 B로 바뀌면 로그 리포팅 모듈에서 종속성을 다시 수정해야한다.
2. 추상화가 세부 사항에 의존하면 안된다. 세부 사항이 추상화에 의존해야한다.
   - 세부 사항 : 구현화 클래스
   - 즉, 추상화 클래스가 구현화 클래스에 의존하면 안된다.

- 쉬운 표현
  - 모든 클래스는 변하기 쉬운 클래스(구현체)에 의존하면 안된다.
  - __변하기 쉬운 클래스에 의존성을 만들지 말라__
- 의존성 주입이란? -- _수정이 필요함_
  - 위 원칙을 따르면 의존성이 interface를 통해서 발생하는데, 이렇게 되면 상위 모듈 객체를 생성할 떄마다 interface에 결합되는 구현화 객체를 생성해서 상위 모듈의 생성자에게 전달해주어야한다.
    - 이걸 수동으로하면 번거롭고 나중에 혹시 수정할 일이 있으면 하드 코딩해야하므로 의존성 주입이라는 기법을 사용한다.
    - 의존성 주입으로 어떤 객체를 생성하고 그 객체에는 해당 interface의 원하는 구현화 객체가 binding되어 있다.
    - 그러한 구현화 객체를 이용해서 상위 모듈을 생성하면 자동으로 하위 모듈이 전달된다.



# 생성 패턴

- 객체를 생성하는 방법에 대한 패턴
  - 스택, 힙, 일반 포인터, 스마트 포인터 등 여러 객체 생성 방법에 대해서 이러한 상황에서는 어떻게 객체를 생성하는 것이 좋은가에 대한 패턴

## 1. 빌더, Builder

- 생성자 호출 코드 단 한줄로 생성할 수 없는 객체를 생성할 때 사용한다.
  - 객체를 생성하는데 여러가지 작업이 수반돼야 할 때, 그것들을 묶어서 처리할 수 있는 도구를 제공한다.
  - 빌더의 여러 멤버 함수들을 사용해서 하나의 객체를 생성한다.
- ex) string 객체
  - 여러 string 객체로 연결된 string 객체를 생성해야할 떄
- 의도 전달
  - 빌더를 만들었다면 해당 객체는 빌더를 이용해서만 객체를 생성할 수 있게 생성자를 막아야한다,



## 2. 팩터리, Factory

- 한 클래스의 객체 생성 방법이 다양해야할 때 사용한다.

  - 생성자로 객체 생성 방법을 다양하게 할 수 없을 때 사용한다.
  - ex) float x,y 또는 float r,theta 를 이용해서 생성되는 Point 객체
    - 같은 타입의 인자를 전달받으므로 생성자로 구분 불가능, 팩터리를 사용한다.
    - 팩터리는 멤버 함수 형태로 함수를 생성하므로 더 직관적인 이름으로 객체를 생성할 수도 있다.

- Factory의 종류

  1. 내부 팩터리

     - 팩터리가 클래스 내부에 존재
     - 한 팩터리가 한 클래스의 객체만을 생성할 때 유용하다.

  2. 추상 팩터리

     - 한 팩터리가 여러 클래스의 객체를 생성해야할 떄 사용

     - 각 클래스에 해당되는 팩터리들을 모아서 추상화하여 사용
     - 생성자를 막아놓고, factory를 friend 선언해서 factory의 멤버함수를 이용하여 객체 생성.
       - factory : factory method로만 구성된 class

- 구현 방법
  - static 함수로 `auto p = Point::NewPolar(1, PI)`와 같은 방법으로 객체를 생성한다.
    - 이것을 Factory method라 한다.

## 3. 프로토 타입, Prototype

- 기존에 생성된 객체(프로토 타입)를 복제해서 새로운 객체를 생성하는 패턴
  - B,C,D...객체들이 A객체와 거의 같지만 세부 사항이 조금씩 다를 때 사용한다.
  - 기존에 생성된 객체를 복제하고 세부 사항은 커스터마이즈하여 사용한다.
- 객체를 복제하는 방법
  1. 복사 생성자
     - 깊은 복사를 통해 복사
     - 복제 생성자를 매번 구현해주어야한다는 불편함과 컴파일 에러를 잡을 수 없다.
  2.  Clone interface 구현
     - 해당 객체의 클래스에 clone interface를 구현한다.
  3. 직렬화
     - 객체를 직렬화, 역직렬화 하여 복제한다.
- 프로토 타입 팩터리
  - 객체 안에 프로토 타입을 선언, 정의 해놓고 팩터리를 통해 복제와 동시에 객체를 구현한다.



## 빌더, 팩터리, 프로토 타입

- 빌더는 여러 단계에 거쳐서 객체를 생성한다.
- 팩터리는 한번에 객체를 생성한다.
- 프로토 타입은 객체를 복제해서 생성한다.



## 4. 싱글턴, Singleton

- 어플리케이션 전체에서 딱 하나의 객체만 존재해야할 떄 사용하는 패턴
  - ex) 데이터 베이스
    - 데이터 베이스는 메모리에 여러번 로딩될 필요가 없다. 딱 한번만 로딩하고 여러 곳에서 접근을 허락하면 된다.
- 구현 방법 :
  - 생성자를 모두 지우고 static member 함수를 통해 static 객체 pointer를 return함.
  - 그런데, static은 초기화, 소멸 순서가 순서대로 안되기 때문에 이중 소멸의 가능성이 있음.
- 문제 상황 :
  - 싱글턴 클래스가 다른 싱글턴 클래스를 참조하면 단위 테스트가 힘들다.
    - 싱글턴 클래스는 static이기 때문에 dummy로 대체할 수가 없다.
    - 내부 클래스에서 dummy를 참조할 지, 싱글턴 객체를 참조할 지 고를 수 있는 interface를 구현해야 한다.
  - 종속성 문제
    - 싱글턴을 일반 클래스로 되돌려야하는 상황이 오면 종속성 때문에 수정해야할 부분들이 많아진다.
    - 싱글턴을 만들 때는 __Inversion of Control(IOC)__ container로 싱글턴 인스턴스를 만들어서 쓰자.

# 구조 패턴

- 객체 구조를 설계하는 패턴
- 객체 구조를 설계하는 방법 3가지
  1. 상속
  2. Composition
     - 한 객체안에 다른 객체를 포함하는 것
  3. aggregation
     - 한 객체 안에서 외부 객체를 참조하여 구성된 객체

## 5. 어댑터, adaptor

- 구현된 인터페이스가 용도에 맞지 않을 때, 용도에 맞게 변환해주는 클래스
- 일시적 어댑터 문제
  - 변환된 객체를 여러번 써야하는 상황에 매번 변환하는 것은 손해.
  - 어댑터 내부에서 vector 또는 해쉬로 cashing한다.

## 6. 브릿지, bridge

### Pimpl

- 클래스의 구현부를 다른 클래스에 숨긴다.
  - 클래스의 선언은 hpp, 구현부 클래스는 cpp에 선언 및 정의.
- 왜 사용하는가?
  1. 구현부를 헤더에서 cpp파일로 숨겨서 공개를 막을 수 있다.
  2. 바이너리 호환성을 보증하기 쉬워진다. _수정 필요_
  3. 클래스가 멤버 선언에 필요한 헤더만을 포함하게 된다.
     - 구현부 클래스에 필요한 헤더들은 따로 cpp파일에서 include한다.
     - 만약, 해당 클래스에서 a 헤더를 포함하는데, a헤더가 변경되면 해당 클래스를 참조하는 모든 파일들도 재 컴파일 해야한다. 이때, 구현부 cpp파일에서만 참조하고 있으면 cpp파일만 재 컴파일하면 된다.

### 브릿지 패턴

- 한 클래스가 다른 클래스를 포함해서 다른 클래스의 기능을 사용하는 것.
  - ex) circle을 다양한 방법으로 그리기
    - circle 클래스가 draw interface를 참조하고 draw A 객체를 전달받아서 circle 객체를 생성한다.
    - 이때, draw interface의 그리기를 실행하면 circle 그리기A를 실행하게 된다.
    - 만약, draw B 객체를 전달받는다면 똑같이, draw interface의 그리기를 실행하면 circle 그리기B가 실행된다.
    - 구현부인 draw interface는 자신이 참조되고 있는지사용되고 있는지 모른다.
- 각 클래스의 존재는 알지만(참조를 통해) 상세구현은 모르는 상태(인터페이스이므로)로 클래스끼리 연동된다.



## 7. 컴포지트

- 여러 구성요소(객체, 변수 등)로 구성된 객체에서 개별 인터페이스를 동일하게 가져가게 하는 방법
  - ex) 힘, 민, 지 속성(변수)을 갖는 creature 객체에서 3 가지 속성의 총 합을 구하고 싶다.
    - 각 변수에 직접 접근하여 속성 값을 구해서 더하는 것 보다 creature.begin~end로 접근하는 것이 더 낫다.
      - 모든 변수에 접근하는 방법이 동일한 인터페이스를 갖는다.
    - 만약 속성이 추가되면 직접 접근 방식에서는 해당 변수에 접근하는 방식을 또 추가해야한다.

- 객체의 구성요소들이 서로 대응되는 관계일 때, 동일한 인터페이스로 접근하게 하는 패턴

## 8. 데커레이터 Decorator

- 기존의 클래스를 수정하지 않으면서 기능을 확장하는 방법
  - Composition을 이용한다.
  - 상속은 불가능한 상황이 있기 때문에 부적합하다.

### 동적 데커레이터

- 런타임에 유저의 반응에 따라 composition을 만든다. 유연하다.
- 중복해서 나타내고 싶은 속성 클래스를 멤버로 두고 재귀적으로 사용한다.

### 정적 데커레이터

- 템플릿을 이용해서 컴파일 시점에 컴포지션을 만든다.
- 동적 데커레이터는 속성 클래스를 멤버로 두기 떄문에 속성 클래스의 멤버 함수 사용이 불가능하다.
  - 믹스인 상속을 사용해서 위 기능을 구현할 수도 있다.
    - 템플릿 인자로 받은 클래스를 부모 클래스로 상속
  - 베이스를 상속하고 A속성 클래스를 상속하면서  B 속성 클래스를 생성

## 9. 퍼사드, Facade

- 복잡한 시스템을 추상화하여 유저가 쉽게 접근할 수 있게 하는 패턴



## 10. 플라이웨이트, Flyweight

- 많은 수의 가벼운 임시 객체들을 스마트 참조로 사용하는 것
  - 그러한 객체들을 플라이웨이트라 한다.
  - 매우 많은 수의 비슷한 객체들이 사용되어야할 때, 메모리 사용량을 절감해준다.
  - ex) 게임에서 John smith라는 유저들이 100명 있다.
    - 100명이 각각 그 이름을 갖는 것 보다 1개의 이름을 선언하고 100명이 그 이름을 가르키는 포인터를 갖는 것이 더 좋다.



## 11. 프록시, Proxy

- 어떤 객체의 기능을 수정 없이 확장한다.
  - 데커레이터 패턴과 달리 기존 API의 방식을 동일하게 유지한다.
  - 같은 API를 사용하면서 다른 동작을 하도록하는 패턴.
  - ex) 스마트 포인터
    - 일반 포인터와 완전히 같은 사용법(API)이지만 기능이 다르다.



### 가상 프록시

- 객체를 생성하되 바로 객체에 자원을 할당하지 않고(로딩) 나중에 하는 것.
  - ex) 이미지 같은 경우에 바로 로딩하지 않고 화면에 이미지를 뿌리는 명령이 들어올 때, 로딩할 수 있다.

### 커뮤니케이션 프록시

- 객체의 물리적 위치를 바꾸면서(클라우드로 이동 등)같은 API를 유지하도록 해준다.



# 행태 패턴

- 구조 패턴 : 객체의 구성 방식에 대한 패턴
- 행태 패턴 : 어떤 기능을 어떻게 구현할 것인가에 대한 패턴



## 12. 책임 사슬, Chain of Responsibility

- A에게 event가 일어났을 때, B에게 이벤트가 전달되며 연속적으로 서로 다른 객체에 event를 전달하는 패턴

### 포인터 사슬

- top modifier를 만들어서 handle 기능과 다음 modifier를 가르키는 포인터를 만든다.
- 실제 구현 modifier들은 top modifier를 상속받고 handle과 top modifier의 handle을 실행한다.
- top modifier에 구현 modifier들을 등록해놓고 handle을 실행하면 모든 modifier들이 연속적으로 실행된다.
- 포인터 사슬은 linked list 구조의 패턴이다.

### 브로커 사슬

- 해당 이벤트로 인한 변화가 해당 스코프내에서만 일어나야할 때 사용하는 패턴
- 중앙에 컴포넌트(이벤트 브로커)를 두고 각 컴포넌트들이 이벤트 브로커의 관리를 받는 구조.



## 13. 커맨드 패턴, Command

- 어떤 객체를 활용할 때, 그 객체의 API를 직접 활용하는 대신 그 기능을 사용하라는 명령을 전달하는 패턴
  - 콜스택 추적에 좋다.

## 14. 인터프리터, interpreter

- 입력 데이터를 해석하는 패턴
  - 수자 리터럴을 바이너리로 변환하는 패턴
  - 정규표현식을 해석하는 패턴
  - CSV, XML, JSON을 해석하는 패턴
- 표현식 해석 구조
  1. __렉싱__
     - 문자열을 토큰 단위로 나열한다.
       - 토큰 : 문법상에서 의미를 갖는 최소 단위
       - 표현식을 토큰들의 나열로 변환
  2. __파싱__
     - 토큰의 나열을 의미있는 단위로 나눈다.
- 인터프리터는 라이브러리를 사용하자.



## 15. 반복자, Iterator

- 복잡한 데이터 구조를 다룰 때, 데이터의 순회 문제가 중요하다.
- 이러한 데이터 순회 문제를 해결하는 패턴
- __반복자__ : 어떤 데이터 컬렉션에서 항목 하나에 접근하는 방법과 다음 항목으로 이동하는 방법을 알고 있는 것.
- 코루틴을 통해 구현 ---_수정 필요_



## 16. 매개자, Mediator

- 클래스간의 커뮤니케이션을 돕기 위한 메커니즘
  - 클래스간의 이벤트 교환
  - 보통 포인터를 이용해서 서로를 참조
    - 이는 명시적으로 상대방 객체의 존재를 알아야함.
- 구현 방법 :
  - 매개자를 두고 매개자에 객체들을 등록한다.
    - 매개자를 통해 이벤트를 주고 받을 객체들의 이름을 찾고 참조를 획득하여 이벤트를 주고 받는다.
  - 이벤트 기반 구조
    - Boost.Signal2 라이브러리를 이용해서 클래스간에 이벤트 signal을 주고 받는다.



## 17. 메멘토, Memento

- 특정 시점의 시스템 상태를 전용 객체에 저장하여 리턴하는 패턴
  - 이러한 객체를 토큰이라 부른다.
  - 메멘토 객체는 생성시를 제외하면 값을 바꿀 수 없으며 friend 속성으로 저장하려는 상태의 객체가 저장된 값에 접근할 수 있다.



## 18. NULL 객체

- 어떤 모듈의 특정 기능을 원하지는 않지만 인터페이스에 내장돼 있어서 구현해야할 때, 사용하는 객체
  - NULL 객체는 인터페이스를 상속받으며 모든 기능을 아무것도 안하는 기능으로 override한다.



## 19. 관찰자, Observer

- 객체의 어떤 상태 변화를 관찰하며 변화를 감지하는 구조
  - 객체의 관찰자 함수가 속성의 변화를 감지하고 콜백을 호출한다.
- 구현 방법 : 
  - 관찰자 들은 private 리스트로 관리된다.
  - 관찰자들은 속성 변경 이벤트에 등록, 해제할 수 있어야 한다.
  - 관찰 대상을 변경하려는 함수에 notify()가 있어야한다.
    - notify()를 통해 등록된 관찰자들에게 이벤트가 전달되어야한다.

## 20. 상태, State _수정 필요_

- 상태가 동작을 제어하고 상태는 바뀔 수 있다.
  - 상태를 통해 동작을 제어한다.
- 구현 방법 2 가지:
  1. 동작을 가지는 실제 클래스로 상태를 정의한다. 그 동작들은 상태가 이전될 때 클래스의 변화에 따라 변경된다.
  2. 상태와 상태전이를 단순히 enum타입처럼 식별자의 나열로 정의한다. 실제 상태 변화는 state machine이라는 특별한 컴포넌트가 수행한다.
     - 전통적인 방식

### 상태 기반 상태 전이

- 상태를 전이할 수단(set_state), 상태를 의미하는 상태 클래스, 개별 상태를 의미하며 상태 전체를 상속하는 상태 클래스로 구성된다.

### State machine 기반 상태 전이

- Boost.MSM을 이용한다.



## 21. 전략, Strategy

- 같은 표현으로 다른 동작을 실행시키고 싶을 때 사용한다.
  - ex) 텍스트를 html 또는 markdown으로 포맷팅하고 싶을 때
- 구현 방법 : 
  - __동적 전략__
    - Strategy 클래스를 action 클래스가 composition으로 포함한다.
    - 각 strategy들은 strategy 클래스를 상속하고 개별 action을 정의한다.
    - 외부에서 action 클래스에 strategy를 정해주면 action class에서 strategy 클래스를 이에 맞게 정하고 strategy안의 action을 실행한다.
  - __정적 전략__
    - 동적 전략과 거의 같지만 composition으로 strategy 클래스를 갖지 않고 template을 통해 곧바로 strategy action 클래스를 composition으로 갖는다.



## 22. 템플릿 메서드, Template method

- 같은 표현으로 다른 동작을 실행시키고 싶을 떄 사용한다.
  - strategy는 composition을, 이것은 상속을 이용한다.
  - 알고리즘의 골격을 base로 두고 상세 구현을 derived에서 한다.
- 구현 방법 :
  - base에서 interface를 구현하고 derived에서 상세 구현을 구현한다.

## 23. 방문자, Visitor

- 소스가 변경이 불가능한데(구조의 변경), 기능이 확장되어야할 때 선제되어야하는 패턴
- 구현 방법
  - __dispatch__
    - 주어진 정보하에서 호출할 함수를 특정하는 방법
    - 함수 오버로딩을 이용해서 각 객체에 따라 다른 기능을 구현한다.
  - __이중 방문자__
    - 방문자 클래스의 멤버함수는 visit()를 갖고 실제 클래스에 구현돼야할 멤버 함수는 accept()이다.
    - 실제 클래스 base가 accept()를 갖고 하위 클래스들이 accep()와 방문자 클래스를 composition으로 갖는다.
    - 하위 방문자 클래스는 상위 방문자 클래스(기능들을 interface로 갖고 있다.)를 상속해서 visitor()(기능별로 오버로딩 되게)에 구현하고 싶은 기능을 넣는다.
    - 하위 클래스의 accept는 방문자 클래스의 visitor()를 실행하도록 overriding한다.
    - 하위 방문자 객체를 생성해서 실제클래스를 arg로 전달하여 추가한 기능을 실행하는 방식으로 사용한다.
    - 위 방식은 순환 방문자 방식으로 오버로딩에 기반한다. 실제 클래스(방문자를 컴포지션)와 방문자 클래스(방문자 클래스를 참조하는 모든 클래스의 타입을 알아야함, 오버로딩하기 위해서) 간에 순환적인 종속성이 있다.
  - __비순환 방문자__
    - 런타임 타입 정보에 의존하므로 실제 클래스의 타입을 방문자 클래스가 알 필요가 없다.
    - 성능적인 부분에서 손해가 있다.
- STL
  - sd::variant, std::visit
    - std::variant로 각 객체 타입을 지정하고 std::visit로 타입에 따라 오버로딩된 함수를 갖는 객체를 넣어서 방문자 패턴을 구현할 수 있다.